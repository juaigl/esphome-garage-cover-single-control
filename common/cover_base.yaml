esphome:
  name: $device_name
  platform: $platform
  board: $board
  on_boot:
    priority: -10
    then:
      - lambda: !lambda |-
          // check cover position
          if (id(open_endstop).state) // door open
          {
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
            id(garage_door).position = esphome::cover::COVER_OPEN;
            id(last_dir) = esphome::cover::COVER_OPERATION_OPENING;
            id(garage_door).publish_state();
          }
          else if (id(close_endstop).state) // door closed
          {
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
            id(garage_door).position = esphome::cover::COVER_CLOSED;
            id(last_dir) = esphome::cover::COVER_OPERATION_CLOSING;
            id(garage_door).publish_state();
          }
          else // door neither closed nor open 
          {
            // last dir not know, so let cover restore last state
          }
globals:
  - id: last_dir
    type: esphome::cover::CoverOperation
    restore_value: yes
    initial_value: esphome::cover::COVER_OPERATION_IDLE
  - id: open_duration
    type: uint32_t
    restore_value: no
    initial_value: $open_duration
  - id: close_duration
    type: uint32_t
    restore_value: no
    initial_value: $close_duration

binary_sensor:
  - platform: gpio
    pin:
      number: $open_endstop_pin
      mode: INPUT_PULLUP
      inverted: true
    name: "Open Endstop Sensor"
    id: open_endstop
    internal: true
    filters:
      - delayed_on_off: $debounce_time
    on_press:
      then:
        - lambda: !lambda |-
            // stop all current actions
            id(push_one).stop();
            // update states
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
            id(garage_door).position = esphome::cover::COVER_OPEN;
            id(last_dir) = esphome::cover::COVER_OPERATION_OPENING;
            id(garage_door).publish_state();
    on_release:
      then:
        - lambda: !lambda |-
            // door was commanded manually (not esphome)
            // set state as closing. This will start position update and reporting
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_CLOSING;
            id(garage_door).publish_state();

  - platform: gpio
    pin:
      number: $close_endstop_pin
      mode: INPUT_PULLUP
      inverted: true
    name: "Close Endstop Sensor"
    id: close_endstop
    internal: true
    filters:
      - delayed_on_off: $debounce_time
    on_press:
      then:
        - lambda: !lambda |-
            // stop all current actions
            id(push_one).stop();
            // update states
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_IDLE;
            id(garage_door).position = esphome::cover::COVER_CLOSED;
            id(last_dir) = esphome::cover::COVER_OPERATION_CLOSING;
            id(garage_door).publish_state();
    on_release:
      then:
        - lambda: !lambda |-
            // door was commanded manually (not esphome)
            // set state as opening. This will start position update and reporting
            id(garage_door).current_operation = esphome::cover::COVER_OPERATION_OPENING;
            id(garage_door).publish_state();

switch:
  - platform: gpio
    pin: $cover_switch_pin
    name: "Cover Switch"
    id: cover_switch
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
    - delay: $active_switch_duration
    - switch.turn_off: cover_switch

cover:
  - platform: template
    name: $device_name
    id: garage_door
    device_class : $cover_device_class
    optimistic: false
    has_position: true
    assumed_state: false
    lambda: |-
      static uint32_t last_recompute_time = 0;
      static uint32_t last_publish_time = 0;
      // store current time
      const uint32_t now = millis();
      // recompute position
      if (id(garage_door).current_operation != COVER_OPERATION_IDLE)  // Door moving
      {
        float dir;
        float action_dur;
        // set dir and duration depending on current movement
        if (id(garage_door).current_operation == COVER_OPERATION_CLOSING)
        {
          dir = -1.0f;
          action_dur = id(close_duration);
        }
        else if (id(garage_door).current_operation == COVER_OPERATION_OPENING)
        {
          dir = 1.0f;
          action_dur = id(open_duration);
        }
        else
        {
          // This should not be reached (maybe on first init when previous operations ar not known). Keep here for security
          return {};
        }
        // calculate position
        float position = id(garage_door).position;
        position += dir * (now - last_recompute_time) / action_dur;
        id(garage_door).position = clamp(position, 0.0f, 1.0f);
        // publish position every second
        if (now - last_publish_time > 1000)
        {
          id(garage_door).publish_state();
          last_publish_time = now;
        }      
      }
      last_recompute_time = now;
      return {};
    open_action:
      - logger.log:
          format: "Open Action - CO:%u PO:%f LD:%u"
          args: [id(garage_door).current_operation, id(garage_door).position, id(last_dir)]
      - if:
          condition:
            lambda: |-
              return (id(open_endstop).state || id(garage_door).current_operation == COVER_OPERATION_OPENING || id(push_one).is_running() == true);
          then:
            # already open or opening
            - logger.log: "Push 0 Times"
          else:
            - if:
                condition:
                  lambda: |-
                    return id(garage_door).current_operation == COVER_OPERATION_IDLE;
                then:
                  - if:
                      condition:
                        lambda: |-
                          return id(last_dir) == COVER_OPERATION_CLOSING;
                      then:
                        # stopped (last: closing) -> opening
                        - script.execute: push_one
                      else:
                        # stopped (last: opening) -> closing -> stop -> opening
                        - script.execute: push_one
                        - cover.template.publish:
                            id: garage_door
                            current_operation: CLOSING
                        - lambda: id(last_dir) = COVER_OPERATION_CLOSING;
                        - script.wait: push_one
                        - script.execute: push_one
                        - cover.template.publish:
                            id: garage_door
                            current_operation: IDLE
                        - script.wait: push_one
                        - script.execute: push_one
                else:
                  # closing -> stop -> opening
                  - script.execute: push_one
                  - cover.template.publish:
                      id: garage_door
                      current_operation: IDLE
                  - script.wait: push_one
                  - script.execute: push_one
            # update states
            - lambda: |-
                id(last_dir) = COVER_OPERATION_OPENING;
                id(garage_door).current_operation = COVER_OPERATION_OPENING;
                id(garage_door).publish_state();
    
    close_action:
      - logger.log:
          format: "Close Action - CO:%u PO:%f LD:%u"
          args: [id(garage_door).current_operation, id(garage_door).position, id(last_dir)]
      - if:
          condition:
            lambda: |-
              return (id(close_endstop).state || id(garage_door).current_operation == COVER_OPERATION_CLOSING || id(push_one).is_running() == true);
          then:
            # already closed or closing
            - logger.log: "Push 0 Times"
          else:
            - if:
                condition:
                  lambda: |-
                    return id(garage_door).current_operation == COVER_OPERATION_IDLE;
                then:
                  - if:
                      condition:
                        lambda: |-
                          return id(last_dir) == COVER_OPERATION_OPENING;
                      then:
                        # stopped (last: opening) -> closing
                        - script.execute: push_one
                      else:
                        # stopped (last: closing) -> opening -> stop -> closing
                        - script.execute: push_one
                        - cover.template.publish:
                            id: garage_door
                            current_operation: OPENING
                        - script.wait: push_one
                        - script.execute: push_one
                        - cover.template.publish:
                            id: garage_door
                            current_operation: IDLE
                        - script.wait: push_one
                        - script.execute: push_one
                else:
                  # opening -> stop -> closing
                  - script.execute: push_one
                  - cover.template.publish:
                      id: garage_door
                      current_operation: IDLE
                  - script.wait: push_one
                  - script.execute: push_one
            # update states
            - lambda: |-
                id(last_dir) = COVER_OPERATION_CLOSING;
                id(garage_door).current_operation = COVER_OPERATION_CLOSING;
                id(garage_door).publish_state();

    stop_action:
      - logger.log:
          format: "Stop Action - CO:%u PO:%f LD:%u"
          args: [id(garage_door).current_operation, id(garage_door).position, id(last_dir)]
      - if:
          condition:
            lambda: |-
              return (id(garage_door).current_operation != COVER_OPERATION_IDLE && id(push_one).is_running() == false);
          then:
            # stop cover
            - script.execute: push_one
            - cover.template.publish:
                id: garage_door
                current_operation: IDLE
          else:
            # already stopped or performing dir change
            - logger.log: "Push 0 Times"

script:
  - id: push_one
    mode: queued
    max_runs: 3
    then:
      - logger.log: "Push 1 Times"
      - switch.turn_on: cover_switch
      - delay: $safe_delay
