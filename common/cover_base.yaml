esphome:
  name: $device_name
  platform: $platform
  board: $board
  includes:
    - common/cover_base.h
  on_boot:
    priority: -10
    then:
      - lambda: |-
          // check cover position
          auto custom_door = static_cast<CustomGarageCover *>(id(garage_door));
          if (id(open_endstop).state) // door open
          {
            custom_door->current_operation = esphome::cover::COVER_OPERATION_IDLE;
            custom_door->position = esphome::cover::COVER_OPEN;
            custom_door->last_dir = esphome::cover::COVER_OPERATION_OPENING;
            custom_door->publish_state();
          }
          else if (id(close_endstop).state) // door closed
          {
            custom_door->current_operation = esphome::cover::COVER_OPERATION_IDLE;
            custom_door->position = esphome::cover::COVER_CLOSED;
            custom_door->last_dir = esphome::cover::COVER_OPERATION_CLOSING;
            custom_door->publish_state();
          }
          else // door neither closed nor open 
          {
            // last dir not know, so let cover restore last state
          }

binary_sensor:
  - platform: gpio
    pin:
      number: $open_endstop_pin
      mode: INPUT_PULLUP
      inverted: true
    name: "Open Endstop Sensor"
    id: open_endstop
    internal: true
    filters:
      - delayed_on_off: $debounce_time
    on_press:
      then:
        - lambda: |-
            auto custom_door = static_cast<CustomGarageCover *>(id(garage_door));
            // notify sensor endstop reached
            custom_door->open_endstop_reached();
    on_release:
      # door was commanded manually (not esphome)
      then:
        - lambda: |-
            auto custom_door = static_cast<CustomGarageCover *>(id(garage_door));
            // notify sensor endstop released
            custom_door->open_endstop_released();

  - platform: gpio
    pin:
      number: $close_endstop_pin
      mode: INPUT_PULLUP
      inverted: true
    name: "Close Endstop Sensor"
    id: close_endstop
    internal: true
    filters:
      - delayed_on_off: $debounce_time
    on_press:
      then:
        - lambda: |-
            auto custom_door = static_cast<CustomGarageCover *>(id(garage_door));
            // notify sensor endstop reached
            custom_door->close_endstop_reached();
    on_release:
      # door was commanded manually (not esphome)
      then:
        - lambda: |-
            auto custom_door = static_cast<CustomGarageCover *>(id(garage_door));
            // notify sensor endstop released
            custom_door->close_endstop_released();

switch:
  - platform: gpio
    pin: $cover_switch_pin
    name: "Cover Switch"
    id: cover_switch
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: $active_switch_duration
      - switch.turn_off: cover_switch

cover:
  - platform: custom
    lambda: |-
      auto my_sensor = new CustomGarageCover(id(cover_switch), $push_interval, $open_duration, $close_duration);
      App.register_component(my_sensor);
      return {my_sensor};

    covers:
      - name: $device_name
        id: garage_door
        device_class: $cover_device_class
